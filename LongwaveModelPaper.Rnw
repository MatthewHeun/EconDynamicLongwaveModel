% This article has been prepared with RStudio with knitr for publication in The B.E. Journal of Macroeconomics:
% http://www.degruyter.com/view/j/bejm.

\documentclass[letterpaper,12pt]{article}
\usepackage{dgjournal}          
\usepackage{mathptmx}
\usepackage{graphicx} % Allows use of width and scale options for \includegraphics
\usepackage{hyperref} % To create hyperlinks in the paper
\usepackage{soul} % Provides strikethrough text
\usepackage[authoryear,comma,longnamesfirst,sectionbib]{natbib} 
%% The lineno packages adds line numbers. Start line numbering with
%% \begin{linenumbers}, end it with \end{linenumbers}. Or switch it on
%% for the whole article with \linenumbers after \end{frontmatter}.
\usepackage{lineno}
\linenumbers % Turns on line numbering for the entire document.

\begin{document}

<<setup_parent, echo=FALSE, message=FALSE, eval=TRUE>>=
require(deSolve)
require(knitr)
require(lattice)
require(latticeExtra)
require(ggplot2)
require(car)
require(mosaic)
require(xtable)
require(reshape2) # Provides access to data melting. See http://cran.r-project.org/web/packages/reshape2/reshape2.pdf
# tikz allows use of LaTeX formatting and font in graphs. Allows for a consistent look across the paper.
# See http://r-forge.r-project.org/R/?group_id=440 for instructions on installing tikzDevice.
require(tikzDevice) 
trellis.par.set(theme=theme.mosaic())
options(width=75)
options(show.signif.stars=TRUE)
opts_chunk$set(
  # ********************************************************************************************************
  eval=FALSE,
  # ********************************************************************************************************
  dev='tikz',    #Allows LaTeX code in graphical output. E.g., "$y$" for a variable name in the legend for a graph.
  tidy=FALSE,
  comment=NA,
  #Tells whether to cache output from chunks are saved. Cacheing saves time. 
  #However, references to LaTeX tables DO NOT WORK if cacheing is turned on (i.e., cache=TRUE).
  cache=FALSE,
  warning=FALSE,  #Tells whether to show warnings in the output.
  message=FALSE, #Turns off messages for all chunks. Set TRUE on an individual chunk to see it.
  echo=FALSE     #Tells whether to echo code for all chunks. Set TRUE on an individual chunk to see its code.
)

########### Several global parameters for graphs. Set here and use below to ensure consistent appearance of graphs.
maxWidth <- 6.5 #Inches
# Full page lattice plot sizes
threePanelGraphWidth <- maxWidth
threePanelGraphHeight <- 3.17 #Inches
ninePanelGraphWidth <- maxWidth     
ninePanelGraphHeight <- 7.5  #Inches
presentationGraph1RowHeight <- 2.8 #Inches
presentationGraph2ColWidth <- 2 #Inches
presentationGraph1ColWidth <- 2*presentationGraph2ColWidth
keyTextSize <- 0.85 #85% of normal size
keyColumns <- 1 #Want only 1 column in the key for lattice graphs
defaultKeyXLoc <- 0.01 #x position of the key. This default is good for 9-panel graphs.
defaultKeyYLoc <- 0.95 #y position of the key. This default is good for 9-panel graphs.
# Other graph parameters that apply to all graphs
scaleTextSize <- 0.8  #Multiple of normal size
scaleTickSize <- -0.5 #50% of normal size and pointing INWARD!
@

<<Historical_Time_Series, eval=TRUE>>=
# Load raw data
rawData <- read.table(file="data/USData.txt", header=TRUE, row.names=1, sep="\t")
data <- rawData #Duplicate the raw data into a new data.frame that we'll manipulate.
# Calculate other raw data items
L_Y <- data["L"] - data["L_A"]; names(L_Y)  <- "L_Y"
data <- cbind(data, L_Y)
# Calculate indexed data
firstYear <- "1980"
Y_0  <- data[firstYear, "Y"]  # Initial GDP
N_0 <- data[firstYear, "N"]   # Initial population
L_Y_0 <- L_Y[firstYear,"L_Y"] # Initial L_Y
y <- data["Y"] / Y_0; names(y) <- "y" # Indexed GDP
n <- data["N"] / N_0; names(n) <- "n" # Indexed population
l_Y <- (data["L"] - data["L_A"]) / L_Y_0; names(l_Y) <- "l_Y" # Indexed workers

# Calculate per-capita information
b <- data["B"] / data["N"]; names(b) <- "b" # Per-capita births
d <- data["D"] / data["N"]; names(d) <- "d" # Per-capita deaths


data <- cbind(data, y, n, l_Y, b, d)



@

<<US_DATA, results='asis', label="tab:US_Data", eval=TRUE>>=
dataXtable <- xtable(x=data[, 10:15], caption="Data for the U.S.", label=paste("tab:US_Data"))
print(dataXtable, caption.placement="top", sanitize.rownames.function = identity, size="\\tiny")
@

<<Test_DAE_Solver>>=
###########################
# Example of an ODE using the van der Pol equation from the examples in 
# Soetaert, Karline, Thomas Petzoldt, and R Woodrow Setzer. 2010. “Solving Differential Equations in R.” 
# The R Journal 2 (2) (December 30): 1–11.
##
vdpol <- function (t, y, mu) {
          # Dereference the names into something more readable.
          y1 <- y["y1"]
          y2 <- y["y2"]
          # Calculate derivatives
          dy1dt <- y2
          dy2dt <- mu * (1 - y1^2) * y2 - y1
          # Build an outgoing list of the derivatives
          out <- list(c(dy1dt=dy1dt, dy2dt=dy2dt))
          return(out)
}

yini <- c(y1 = 2, y2 = 0)
stiff    <- ode(y = yini, func = vdpol, times = 0:3000,                parms = 1000)
nonstiff <- ode(y = yini, func = vdpol, times = seq(0, 30, by = 0.01), parms = 1)
head(stiff, n = 3)
plot(stiff,    type = "l", which = "y1", lwd = 2, ylab = "y", main = "IVP ODE, stiff")
plot(nonstiff, type = "l", which = "y1", lwd = 2, ylab = "y", main = "IVP ODE, nonstiff")

###########################
# Example of solving a DAE using the Rober problem from the examples in 
# Soetaert, Karline, Thomas Petzoldt, and R Woodrow Setzer. 2010. “Solving Differential Equations in R.” 
# The R Journal 2 (2) (December 30): 1–11.
##
daefun <- function(t, y, dy, parms) {
            # Reassign variables to readable names
            y1 <- y["y1"]; y2 <- y["y2"]; y3 <- y["y3"]
            dy1dt <- dy[1]; dy2dt <- dy[2] # no named parameters
            # Calculate residuals
            res1 <- - 0.04 * y1 + 1e4 * y2 * y3 - dy1dt
            res2 <- 0.04 * y1 - 1e4 * y2 * y3 - 3e7 * y2^2 - dy2dt
            res3 <- y1 + y2 + y3 - 1
            # Bundle for output
            out <- list(c(R1=res1, R2=res2, R3=res3), error = as.vector(res3))
            return(out)
}
yini <- c(y1=1, y2=0, y3=0) 
dyini <- c(-0.04, 0.04, 0)
times <- 10 ^ seq(-6, 6, 0.1)
print(system.time(out <- daspk(y=yini, dy=dyini, times=times, res=daefun, parms=NULL)))
plot(out, ylab="conc.", xlab="time", type="l", lwd=2, log="x")
mtext("IVP DAE", side=3, outer=TRUE, line=-1)
@


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\appendix
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Raw Data} 
\label{sec:Raw_Data}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The following table shows raw data for the U.S.

<<Raw_US_Data, results='asis', label="tab:Raw_US_Data", eval=TRUE>>=
rawDataXtable <- xtable(x=rawData, caption="Raw data for the U.S.", label=paste("tab:Raw_US_Data"))
print(rawDataXtable, caption.placement="top", sanitize.rownames.function = identity, size="\\tiny")
@



%% BibTeX support
\bibliographystyle{DeGruyter}
\bibliography{LongwaveModelPaper}

\end{document}